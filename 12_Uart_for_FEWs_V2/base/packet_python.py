'''
MAVLink protocol implementation (auto-generated by mavgen.py)

Generated from: mavlink_main.xml,bootloader.xml,smartseat.xml,bluetooth.xml,pass.xml

Note: this file has been auto-generated. DO NOT EDIT
'''
from __future__ import print_function
from builtins import range
from builtins import object
import struct, array, time, json, os, sys, platform

from pymavlink.generator.mavcrc import x25crc
import hashlib

WIRE_PROTOCOL_VERSION = '1.0'
DIALECT = 'packet_python'

PROTOCOL_MARKER_V1 = 0xFE
PROTOCOL_MARKER_V2 = 0xFD
HEADER_LEN_V1 = 6
HEADER_LEN_V2 = 10

MAVLINK_SIGNATURE_BLOCK_LEN = 13

MAVLINK_IFLAG_SIGNED = 0x01

native_supported = platform.system() != 'Windows' # Not yet supported on other dialects
native_force = 'MAVNATIVE_FORCE' in os.environ # Will force use of native code regardless of what client app wants
native_testing = 'MAVNATIVE_TESTING' in os.environ # Will force both native and legacy code to be used and their results compared

if native_supported and float(WIRE_PROTOCOL_VERSION) <= 1:
    try:
        import mavnative
    except ImportError:
        print('ERROR LOADING MAVNATIVE - falling back to python implementation')
        native_supported = False
else:
    # mavnative isn't supported for MAVLink2 yet
    native_supported = False

# allow MAV_IGNORE_CRC=1 to ignore CRC, allowing some
# corrupted msgs to be seen
MAVLINK_IGNORE_CRC = os.environ.get("MAV_IGNORE_CRC",0)

# some base types from mavlink_types.h
MAVLINK_TYPE_CHAR     = 0
MAVLINK_TYPE_UINT8_T  = 1
MAVLINK_TYPE_INT8_T   = 2
MAVLINK_TYPE_UINT16_T = 3
MAVLINK_TYPE_INT16_T  = 4
MAVLINK_TYPE_UINT32_T = 5
MAVLINK_TYPE_INT32_T  = 6
MAVLINK_TYPE_UINT64_T = 7
MAVLINK_TYPE_INT64_T  = 8
MAVLINK_TYPE_FLOAT    = 9
MAVLINK_TYPE_DOUBLE   = 10


# swiped from DFReader.py
def to_string(s):
    '''desperate attempt to convert a string regardless of what garbage we get'''
    try:
        return s.decode("utf-8")
    except Exception as e:
        pass
    try:
        s2 = s.encode('utf-8', 'ignore')
        x = u"%s" % s2
        return s2
    except Exception:
        pass
    # so it's a nasty one. Let's grab as many characters as we can
    r = ''
    try:
        for c in s:
            r2 = r + c
            r2 = r2.encode('ascii', 'ignore')
            x = u"%s" % r2
            r = r2
    except Exception:
        pass
    return r + '_XXX'


class MAVLink_header(object):
    '''MAVLink message header'''
    def __init__(self, msgId, incompat_flags=0, compat_flags=0, mlen=0, seq=0, srcSystem=0, srcComponent=0):
        self.mlen = mlen
        self.seq = seq
        self.srcSystem = srcSystem
        self.srcComponent = srcComponent
        self.msgId = msgId
        self.incompat_flags = incompat_flags
        self.compat_flags = compat_flags

    def pack(self, force_mavlink1=False):
        if WIRE_PROTOCOL_VERSION == '2.0' and not force_mavlink1:
            return struct.pack('<BBBBBBBHB', 254, self.mlen,
                               self.incompat_flags, self.compat_flags,
                               self.seq, self.srcSystem, self.srcComponent,
                               self.msgId&0xFFFF, self.msgId>>16)
        return struct.pack('<BBBBBB', PROTOCOL_MARKER_V1, self.mlen, self.seq,
                           self.srcSystem, self.srcComponent, self.msgId)

class MAVLink_message(object):
    '''base MAVLink message class'''
    def __init__(self, msgId, name):
        self._header     = MAVLink_header(msgId)
        self._payload    = None
        self._msgbuf     = None
        self._crc        = None
        self._fieldnames = []
        self._type       = name
        self._signed     = False
        self._link_id    = None
        self._instances  = None
        self._instance_field = None

    def format_attr(self, field):
        '''override field getter'''
        raw_attr = getattr(self,field)
        if isinstance(raw_attr, bytes):
            raw_attr = to_string(raw_attr).rstrip("\00")
        return raw_attr

    def get_msgbuf(self):
        if isinstance(self._msgbuf, bytearray):
            return self._msgbuf
        return bytearray(self._msgbuf)

    def get_header(self):
        return self._header

    def get_payload(self):
        return self._payload

    def get_crc(self):
        return self._crc

    def get_fieldnames(self):
        return self._fieldnames

    def get_type(self):
        return self._type

    def get_msgId(self):
        return self._header.msgId

    def get_srcSystem(self):
        return self._header.srcSystem

    def get_srcComponent(self):
        return self._header.srcComponent

    def get_seq(self):
        return self._header.seq

    def get_signed(self):
        return self._signed

    def get_link_id(self):
        return self._link_id

    def __str__(self):
        ret = '%s {' % self._type
        for a in self._fieldnames:
            v = self.format_attr(a)
            ret += '%s : %s, ' % (a, v)
        ret = ret[0:-2] + '}'
        return ret

    def __ne__(self, other):
        return not self.__eq__(other)

    def __eq__(self, other):
        if other is None:
            return False

        if self.get_type() != other.get_type():
            return False

        # We do not compare CRC because native code doesn't provide it
        #if self.get_crc() != other.get_crc():
        #    return False

        if self.get_seq() != other.get_seq():
            return False

        if self.get_srcSystem() != other.get_srcSystem():
            return False

        if self.get_srcComponent() != other.get_srcComponent():
            return False

        for a in self._fieldnames:
            if self.format_attr(a) != other.format_attr(a):
                return False

        return True

    def to_dict(self):
        d = dict({})
        d['mavpackettype'] = self._type
        for a in self._fieldnames:
          d[a] = self.format_attr(a)
        return d

    def to_json(self):
        return json.dumps(self.to_dict())

    def sign_packet(self, mav):
        h = hashlib.new('sha256')
        self._msgbuf += struct.pack('<BQ', mav.signing.link_id, mav.signing.timestamp)[:7]
        h.update(mav.signing.secret_key)
        h.update(self._msgbuf)
        sig = h.digest()[:6]
        self._msgbuf += sig
        mav.signing.timestamp += 1

    def pack(self, mav, crc_extra, payload, force_mavlink1=False):
        plen = len(payload)
        if WIRE_PROTOCOL_VERSION != '1.0' and not force_mavlink1:
            # in MAVLink2 we can strip trailing zeros off payloads. This allows for simple
            # variable length arrays and smaller packets
            nullbyte = chr(0)
            # in Python2, type("fred') is str but also type("fred")==bytes
            if str(type(payload)) == "<class 'bytes'>":
                nullbyte = 0
            while plen > 1 and payload[plen-1] == nullbyte:
                plen -= 1
        self._payload = payload[:plen]
        incompat_flags = 0
        if mav.signing.sign_outgoing:
            incompat_flags |= MAVLINK_IFLAG_SIGNED
        self._header  = MAVLink_header(self._header.msgId,
                                       incompat_flags=incompat_flags, compat_flags=0,
                                       mlen=len(self._payload), seq=mav.seq,
                                       srcSystem=mav.srcSystem, srcComponent=mav.srcComponent)
        self._msgbuf = self._header.pack(force_mavlink1=force_mavlink1) + self._payload
        crc = x25crc(self._msgbuf[1:])
        if True: # using CRC extra
            crc.accumulate_str(struct.pack('B', crc_extra))
        self._crc = crc.crc
        self._msgbuf += struct.pack('<H', self._crc)
        if mav.signing.sign_outgoing and not force_mavlink1:
            self.sign_packet(mav)
        return self._msgbuf

    def __getitem__(self, key):
        '''support indexing, allowing for multi-instance sensors in one message'''
        if self._instances is None:
            raise IndexError()
        if not key in self._instances:
            raise IndexError()
        return self._instances[key]


# enums

class EnumEntry(object):
    def __init__(self, name, description):
        self.name = name
        self.description = description
        self.param = {}

enums = {}

# message IDs
MAVLINK_MSG_ID_BAD_DATA = -1
MAVLINK_MSG_ID_MODE_RESPONSE = 0
MAVLINK_MSG_ID_BOOT_ACK = 1
MAVLINK_MSG_ID_BOOT_COMMAND = 2
MAVLINK_MSG_ID_BOOT_OTA_READ = 3
MAVLINK_MSG_ID_BOOT_OTA_WRITE = 4
MAVLINK_MSG_ID_BOOT_VERSION = 5
MAVLINK_MSG_ID_BOOT_OTA_VERIFY = 6
MAVLINK_MSG_ID_SMARTSEAT_ACK = 21
MAVLINK_MSG_ID_BCG_ACC = 22
MAVLINK_MSG_ID_BIO_STATUS = 23
MAVLINK_MSG_ID_FATIGUE = 24
MAVLINK_MSG_ID_BLE_ACK = 30
MAVLINK_MSG_ID_BLUETOOTH_CHANGE_NAME = 31
MAVLINK_MSG_ID_PASS_1 = 90
MAVLINK_MSG_ID_PASS_2 = 91
MAVLINK_MSG_ID_PASS_4 = 92
MAVLINK_MSG_ID_PASS_8 = 93
MAVLINK_MSG_ID_PASS_16 = 94
MAVLINK_MSG_ID_PASS_32 = 95
MAVLINK_MSG_ID_PASS_64 = 96
MAVLINK_MSG_ID_PASS_128 = 97

class MAVLink_mode_response_message(MAVLink_message):
        '''
        send packet and response the mode
        '''
        id = MAVLINK_MSG_ID_MODE_RESPONSE
        name = 'MODE_RESPONSE'
        fieldnames = ['mode']
        ordered_fieldnames = ['mode']
        fieldtypes = ['uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<B'
        native_format = bytearray('<B', 'ascii')
        orders = [0]
        lengths = [1]
        array_lengths = [0]
        crc_extra = 18
        unpacker = struct.Struct('<B')
        instance_field = None
        instance_offset = -1

        def __init__(self, mode):
                MAVLink_message.__init__(self, MAVLink_mode_response_message.id, MAVLink_mode_response_message.name)
                self._fieldnames = MAVLink_mode_response_message.fieldnames
                self._instance_field = MAVLink_mode_response_message.instance_field
                self._instance_offset = MAVLink_mode_response_message.instance_offset
                self.mode = mode

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 18, struct.pack('<B', self.mode), force_mavlink1=force_mavlink1)

class MAVLink_boot_ack_message(MAVLink_message):
        '''
        command and ack back
        '''
        id = MAVLINK_MSG_ID_BOOT_ACK
        name = 'BOOT_ACK'
        fieldnames = ['ack_code', 'value']
        ordered_fieldnames = ['value', 'ack_code']
        fieldtypes = ['uint8_t', 'uint32_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<IB'
        native_format = bytearray('<IB', 'ascii')
        orders = [1, 0]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 79
        unpacker = struct.Struct('<IB')
        instance_field = None
        instance_offset = -1

        def __init__(self, ack_code, value):
                MAVLink_message.__init__(self, MAVLink_boot_ack_message.id, MAVLink_boot_ack_message.name)
                self._fieldnames = MAVLink_boot_ack_message.fieldnames
                self._instance_field = MAVLink_boot_ack_message.instance_field
                self._instance_offset = MAVLink_boot_ack_message.instance_offset
                self.ack_code = ack_code
                self.value = value

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 79, struct.pack('<IB', self.value, self.ack_code), force_mavlink1=force_mavlink1)

class MAVLink_boot_command_message(MAVLink_message):
        '''
        Bootloader command
        '''
        id = MAVLINK_MSG_ID_BOOT_COMMAND
        name = 'BOOT_COMMAND'
        fieldnames = ['command', 'value']
        ordered_fieldnames = ['value', 'command']
        fieldtypes = ['uint8_t', 'uint32_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<IB'
        native_format = bytearray('<IB', 'ascii')
        orders = [1, 0]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 48
        unpacker = struct.Struct('<IB')
        instance_field = None
        instance_offset = -1

        def __init__(self, command, value):
                MAVLink_message.__init__(self, MAVLink_boot_command_message.id, MAVLink_boot_command_message.name)
                self._fieldnames = MAVLink_boot_command_message.fieldnames
                self._instance_field = MAVLink_boot_command_message.instance_field
                self._instance_offset = MAVLink_boot_command_message.instance_offset
                self.command = command
                self.value = value

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 48, struct.pack('<IB', self.value, self.command), force_mavlink1=force_mavlink1)

class MAVLink_boot_ota_read_message(MAVLink_message):
        '''
        Bootloader ota data read
        '''
        id = MAVLINK_MSG_ID_BOOT_OTA_READ
        name = 'BOOT_OTA_READ'
        fieldnames = ['addr', 'counts', 'value', 'checksum']
        ordered_fieldnames = ['addr', 'checksum', 'counts', 'value']
        fieldtypes = ['uint32_t', 'uint16_t', 'uint8_t', 'uint32_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<IIH128B'
        native_format = bytearray('<IIHB', 'ascii')
        orders = [0, 2, 3, 1]
        lengths = [1, 1, 1, 128]
        array_lengths = [0, 0, 0, 128]
        crc_extra = 94
        unpacker = struct.Struct('<IIH128B')
        instance_field = None
        instance_offset = -1

        def __init__(self, addr, counts, value, checksum):
                MAVLink_message.__init__(self, MAVLink_boot_ota_read_message.id, MAVLink_boot_ota_read_message.name)
                self._fieldnames = MAVLink_boot_ota_read_message.fieldnames
                self._instance_field = MAVLink_boot_ota_read_message.instance_field
                self._instance_offset = MAVLink_boot_ota_read_message.instance_offset
                self.addr = addr
                self.counts = counts
                self.value = value
                self.checksum = checksum

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 94, struct.pack('<IIH128B', self.addr, self.checksum, self.counts, self.value[0], self.value[1], self.value[2], self.value[3], self.value[4], self.value[5], self.value[6], self.value[7], self.value[8], self.value[9], self.value[10], self.value[11], self.value[12], self.value[13], self.value[14], self.value[15], self.value[16], self.value[17], self.value[18], self.value[19], self.value[20], self.value[21], self.value[22], self.value[23], self.value[24], self.value[25], self.value[26], self.value[27], self.value[28], self.value[29], self.value[30], self.value[31], self.value[32], self.value[33], self.value[34], self.value[35], self.value[36], self.value[37], self.value[38], self.value[39], self.value[40], self.value[41], self.value[42], self.value[43], self.value[44], self.value[45], self.value[46], self.value[47], self.value[48], self.value[49], self.value[50], self.value[51], self.value[52], self.value[53], self.value[54], self.value[55], self.value[56], self.value[57], self.value[58], self.value[59], self.value[60], self.value[61], self.value[62], self.value[63], self.value[64], self.value[65], self.value[66], self.value[67], self.value[68], self.value[69], self.value[70], self.value[71], self.value[72], self.value[73], self.value[74], self.value[75], self.value[76], self.value[77], self.value[78], self.value[79], self.value[80], self.value[81], self.value[82], self.value[83], self.value[84], self.value[85], self.value[86], self.value[87], self.value[88], self.value[89], self.value[90], self.value[91], self.value[92], self.value[93], self.value[94], self.value[95], self.value[96], self.value[97], self.value[98], self.value[99], self.value[100], self.value[101], self.value[102], self.value[103], self.value[104], self.value[105], self.value[106], self.value[107], self.value[108], self.value[109], self.value[110], self.value[111], self.value[112], self.value[113], self.value[114], self.value[115], self.value[116], self.value[117], self.value[118], self.value[119], self.value[120], self.value[121], self.value[122], self.value[123], self.value[124], self.value[125], self.value[126], self.value[127]), force_mavlink1=force_mavlink1)

class MAVLink_boot_ota_write_message(MAVLink_message):
        '''
        Bootloader ota data write
        '''
        id = MAVLINK_MSG_ID_BOOT_OTA_WRITE
        name = 'BOOT_OTA_WRITE'
        fieldnames = ['addr', 'counts', 'value', 'checksum']
        ordered_fieldnames = ['addr', 'checksum', 'counts', 'value']
        fieldtypes = ['uint32_t', 'uint16_t', 'uint8_t', 'uint32_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<IIH128B'
        native_format = bytearray('<IIHB', 'ascii')
        orders = [0, 2, 3, 1]
        lengths = [1, 1, 1, 128]
        array_lengths = [0, 0, 0, 128]
        crc_extra = 51
        unpacker = struct.Struct('<IIH128B')
        instance_field = None
        instance_offset = -1

        def __init__(self, addr, counts, value, checksum):
                MAVLink_message.__init__(self, MAVLink_boot_ota_write_message.id, MAVLink_boot_ota_write_message.name)
                self._fieldnames = MAVLink_boot_ota_write_message.fieldnames
                self._instance_field = MAVLink_boot_ota_write_message.instance_field
                self._instance_offset = MAVLink_boot_ota_write_message.instance_offset
                self.addr = addr
                self.counts = counts
                self.value = value
                self.checksum = checksum

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 51, struct.pack('<IIH128B', self.addr, self.checksum, self.counts, self.value[0], self.value[1], self.value[2], self.value[3], self.value[4], self.value[5], self.value[6], self.value[7], self.value[8], self.value[9], self.value[10], self.value[11], self.value[12], self.value[13], self.value[14], self.value[15], self.value[16], self.value[17], self.value[18], self.value[19], self.value[20], self.value[21], self.value[22], self.value[23], self.value[24], self.value[25], self.value[26], self.value[27], self.value[28], self.value[29], self.value[30], self.value[31], self.value[32], self.value[33], self.value[34], self.value[35], self.value[36], self.value[37], self.value[38], self.value[39], self.value[40], self.value[41], self.value[42], self.value[43], self.value[44], self.value[45], self.value[46], self.value[47], self.value[48], self.value[49], self.value[50], self.value[51], self.value[52], self.value[53], self.value[54], self.value[55], self.value[56], self.value[57], self.value[58], self.value[59], self.value[60], self.value[61], self.value[62], self.value[63], self.value[64], self.value[65], self.value[66], self.value[67], self.value[68], self.value[69], self.value[70], self.value[71], self.value[72], self.value[73], self.value[74], self.value[75], self.value[76], self.value[77], self.value[78], self.value[79], self.value[80], self.value[81], self.value[82], self.value[83], self.value[84], self.value[85], self.value[86], self.value[87], self.value[88], self.value[89], self.value[90], self.value[91], self.value[92], self.value[93], self.value[94], self.value[95], self.value[96], self.value[97], self.value[98], self.value[99], self.value[100], self.value[101], self.value[102], self.value[103], self.value[104], self.value[105], self.value[106], self.value[107], self.value[108], self.value[109], self.value[110], self.value[111], self.value[112], self.value[113], self.value[114], self.value[115], self.value[116], self.value[117], self.value[118], self.value[119], self.value[120], self.value[121], self.value[122], self.value[123], self.value[124], self.value[125], self.value[126], self.value[127]), force_mavlink1=force_mavlink1)

class MAVLink_boot_version_message(MAVLink_message):
        '''
        Bootloader or app version
        '''
        id = MAVLINK_MSG_ID_BOOT_VERSION
        name = 'BOOT_VERSION'
        fieldnames = ['request_code', 'version']
        ordered_fieldnames = ['request_code', 'version']
        fieldtypes = ['uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<B4B'
        native_format = bytearray('<BB', 'ascii')
        orders = [0, 1]
        lengths = [1, 4]
        array_lengths = [0, 4]
        crc_extra = 241
        unpacker = struct.Struct('<B4B')
        instance_field = None
        instance_offset = -1

        def __init__(self, request_code, version):
                MAVLink_message.__init__(self, MAVLink_boot_version_message.id, MAVLink_boot_version_message.name)
                self._fieldnames = MAVLink_boot_version_message.fieldnames
                self._instance_field = MAVLink_boot_version_message.instance_field
                self._instance_offset = MAVLink_boot_version_message.instance_offset
                self.request_code = request_code
                self.version = version

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 241, struct.pack('<B4B', self.request_code, self.version[0], self.version[1], self.version[2], self.version[3]), force_mavlink1=force_mavlink1)

class MAVLink_boot_ota_verify_message(MAVLink_message):
        '''
        Verify ota flash
        '''
        id = MAVLINK_MSG_ID_BOOT_OTA_VERIFY
        name = 'BOOT_OTA_VERIFY'
        fieldnames = ['start_addr', 'length', 'checksum']
        ordered_fieldnames = ['start_addr', 'length', 'checksum']
        fieldtypes = ['uint32_t', 'uint32_t', 'uint32_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<III'
        native_format = bytearray('<III', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 23
        unpacker = struct.Struct('<III')
        instance_field = None
        instance_offset = -1

        def __init__(self, start_addr, length, checksum):
                MAVLink_message.__init__(self, MAVLink_boot_ota_verify_message.id, MAVLink_boot_ota_verify_message.name)
                self._fieldnames = MAVLink_boot_ota_verify_message.fieldnames
                self._instance_field = MAVLink_boot_ota_verify_message.instance_field
                self._instance_offset = MAVLink_boot_ota_verify_message.instance_offset
                self.start_addr = start_addr
                self.length = length
                self.checksum = checksum

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 23, struct.pack('<III', self.start_addr, self.length, self.checksum), force_mavlink1=force_mavlink1)

class MAVLink_smartseat_ack_message(MAVLink_message):
        '''
        command and ack back
        '''
        id = MAVLINK_MSG_ID_SMARTSEAT_ACK
        name = 'SMARTSEAT_ACK'
        fieldnames = ['ack_code']
        ordered_fieldnames = ['ack_code']
        fieldtypes = ['uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<B'
        native_format = bytearray('<B', 'ascii')
        orders = [0]
        lengths = [1]
        array_lengths = [0]
        crc_extra = 96
        unpacker = struct.Struct('<B')
        instance_field = None
        instance_offset = -1

        def __init__(self, ack_code):
                MAVLink_message.__init__(self, MAVLink_smartseat_ack_message.id, MAVLink_smartseat_ack_message.name)
                self._fieldnames = MAVLink_smartseat_ack_message.fieldnames
                self._instance_field = MAVLink_smartseat_ack_message.instance_field
                self._instance_offset = MAVLink_smartseat_ack_message.instance_offset
                self.ack_code = ack_code

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 96, struct.pack('<B', self.ack_code), force_mavlink1=force_mavlink1)

class MAVLink_bcg_acc_message(MAVLink_message):
        '''
        Pressure raw data
        '''
        id = MAVLINK_MSG_ID_BCG_ACC
        name = 'BCG_ACC'
        fieldnames = ['timestamp', 'pressure', 'accx', 'accy', 'accz']
        ordered_fieldnames = ['timestamp', 'pressure', 'accx', 'accy', 'accz']
        fieldtypes = ['uint32_t', 'int32_t', 'int32_t', 'int32_t', 'int32_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<Iiiii'
        native_format = bytearray('<Iiiii', 'ascii')
        orders = [0, 1, 2, 3, 4]
        lengths = [1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0]
        crc_extra = 109
        unpacker = struct.Struct('<Iiiii')
        instance_field = None
        instance_offset = -1

        def __init__(self, timestamp, pressure, accx, accy, accz):
                MAVLink_message.__init__(self, MAVLink_bcg_acc_message.id, MAVLink_bcg_acc_message.name)
                self._fieldnames = MAVLink_bcg_acc_message.fieldnames
                self._instance_field = MAVLink_bcg_acc_message.instance_field
                self._instance_offset = MAVLink_bcg_acc_message.instance_offset
                self.timestamp = timestamp
                self.pressure = pressure
                self.accx = accx
                self.accy = accy
                self.accz = accz

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 109, struct.pack('<Iiiii', self.timestamp, self.pressure, self.accx, self.accy, self.accz), force_mavlink1=force_mavlink1)

class MAVLink_bio_status_message(MAVLink_message):
        '''
        Fatigue data
        '''
        id = MAVLINK_MSG_ID_BIO_STATUS
        name = 'BIO_STATUS'
        fieldnames = ['timestamp', 'hr', 'resp', 'status']
        ordered_fieldnames = ['timestamp', 'hr', 'resp', 'status']
        fieldtypes = ['uint32_t', 'uint8_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<IBBB'
        native_format = bytearray('<IBBB', 'ascii')
        orders = [0, 1, 2, 3]
        lengths = [1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0]
        crc_extra = 103
        unpacker = struct.Struct('<IBBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, timestamp, hr, resp, status):
                MAVLink_message.__init__(self, MAVLink_bio_status_message.id, MAVLink_bio_status_message.name)
                self._fieldnames = MAVLink_bio_status_message.fieldnames
                self._instance_field = MAVLink_bio_status_message.instance_field
                self._instance_offset = MAVLink_bio_status_message.instance_offset
                self.timestamp = timestamp
                self.hr = hr
                self.resp = resp
                self.status = status

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 103, struct.pack('<IBBB', self.timestamp, self.hr, self.resp, self.status), force_mavlink1=force_mavlink1)

class MAVLink_fatigue_message(MAVLink_message):
        '''
        Fatigue data
        '''
        id = MAVLINK_MSG_ID_FATIGUE
        name = 'FATIGUE'
        fieldnames = ['timestamp', 'fatigue', 'alarm']
        ordered_fieldnames = ['timestamp', 'fatigue', 'alarm']
        fieldtypes = ['uint32_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<IBB'
        native_format = bytearray('<IBB', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 110
        unpacker = struct.Struct('<IBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, timestamp, fatigue, alarm):
                MAVLink_message.__init__(self, MAVLink_fatigue_message.id, MAVLink_fatigue_message.name)
                self._fieldnames = MAVLink_fatigue_message.fieldnames
                self._instance_field = MAVLink_fatigue_message.instance_field
                self._instance_offset = MAVLink_fatigue_message.instance_offset
                self.timestamp = timestamp
                self.fatigue = fatigue
                self.alarm = alarm

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 110, struct.pack('<IBB', self.timestamp, self.fatigue, self.alarm), force_mavlink1=force_mavlink1)

class MAVLink_ble_ack_message(MAVLink_message):
        '''
        wifi connect
        '''
        id = MAVLINK_MSG_ID_BLE_ACK
        name = 'BLE_ACK'
        fieldnames = ['ack_code']
        ordered_fieldnames = ['ack_code']
        fieldtypes = ['uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<B'
        native_format = bytearray('<B', 'ascii')
        orders = [0]
        lengths = [1]
        array_lengths = [0]
        crc_extra = 5
        unpacker = struct.Struct('<B')
        instance_field = None
        instance_offset = -1

        def __init__(self, ack_code):
                MAVLink_message.__init__(self, MAVLink_ble_ack_message.id, MAVLink_ble_ack_message.name)
                self._fieldnames = MAVLink_ble_ack_message.fieldnames
                self._instance_field = MAVLink_ble_ack_message.instance_field
                self._instance_offset = MAVLink_ble_ack_message.instance_offset
                self.ack_code = ack_code

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 5, struct.pack('<B', self.ack_code), force_mavlink1=force_mavlink1)

class MAVLink_bluetooth_change_name_message(MAVLink_message):
        '''
        BMWSeat control
        '''
        id = MAVLINK_MSG_ID_BLUETOOTH_CHANGE_NAME
        name = 'BLUETOOTH_CHANGE_NAME'
        fieldnames = ['name']
        ordered_fieldnames = ['name']
        fieldtypes = ['uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<20B'
        native_format = bytearray('<B', 'ascii')
        orders = [0]
        lengths = [20]
        array_lengths = [20]
        crc_extra = 63
        unpacker = struct.Struct('<20B')
        instance_field = None
        instance_offset = -1

        def __init__(self, name):
                MAVLink_message.__init__(self, MAVLink_bluetooth_change_name_message.id, MAVLink_bluetooth_change_name_message.name)
                self._fieldnames = MAVLink_bluetooth_change_name_message.fieldnames
                self._instance_field = MAVLink_bluetooth_change_name_message.instance_field
                self._instance_offset = MAVLink_bluetooth_change_name_message.instance_offset
                self.name = name

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 63, struct.pack('<20B', self.name[0], self.name[1], self.name[2], self.name[3], self.name[4], self.name[5], self.name[6], self.name[7], self.name[8], self.name[9], self.name[10], self.name[11], self.name[12], self.name[13], self.name[14], self.name[15], self.name[16], self.name[17], self.name[18], self.name[19]), force_mavlink1=force_mavlink1)

class MAVLink_pass_1_message(MAVLink_message):
        '''
        PASS 1 byte
        '''
        id = MAVLINK_MSG_ID_PASS_1
        name = 'PASS_1'
        fieldnames = ['code', 'val']
        ordered_fieldnames = ['code', 'val']
        fieldtypes = ['uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<B1B'
        native_format = bytearray('<BB', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 1]
        crc_extra = 150
        unpacker = struct.Struct('<B1B')
        instance_field = None
        instance_offset = -1

        def __init__(self, code, val):
                MAVLink_message.__init__(self, MAVLink_pass_1_message.id, MAVLink_pass_1_message.name)
                self._fieldnames = MAVLink_pass_1_message.fieldnames
                self._instance_field = MAVLink_pass_1_message.instance_field
                self._instance_offset = MAVLink_pass_1_message.instance_offset
                self.code = code
                self.val = val

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 150, struct.pack('<B1B', self.code, self.val), force_mavlink1=force_mavlink1)

class MAVLink_pass_2_message(MAVLink_message):
        '''
        PASS 2 byte
        '''
        id = MAVLINK_MSG_ID_PASS_2
        name = 'PASS_2'
        fieldnames = ['code', 'val']
        ordered_fieldnames = ['code', 'val']
        fieldtypes = ['uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<B2B'
        native_format = bytearray('<BB', 'ascii')
        orders = [0, 1]
        lengths = [1, 2]
        array_lengths = [0, 2]
        crc_extra = 86
        unpacker = struct.Struct('<B2B')
        instance_field = None
        instance_offset = -1

        def __init__(self, code, val):
                MAVLink_message.__init__(self, MAVLink_pass_2_message.id, MAVLink_pass_2_message.name)
                self._fieldnames = MAVLink_pass_2_message.fieldnames
                self._instance_field = MAVLink_pass_2_message.instance_field
                self._instance_offset = MAVLink_pass_2_message.instance_offset
                self.code = code
                self.val = val

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 86, struct.pack('<B2B', self.code, self.val[0], self.val[1]), force_mavlink1=force_mavlink1)

class MAVLink_pass_4_message(MAVLink_message):
        '''
        PASS 4 byte
        '''
        id = MAVLINK_MSG_ID_PASS_4
        name = 'PASS_4'
        fieldnames = ['code', 'val']
        ordered_fieldnames = ['code', 'val']
        fieldtypes = ['uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<B4B'
        native_format = bytearray('<BB', 'ascii')
        orders = [0, 1]
        lengths = [1, 4]
        array_lengths = [0, 4]
        crc_extra = 215
        unpacker = struct.Struct('<B4B')
        instance_field = None
        instance_offset = -1

        def __init__(self, code, val):
                MAVLink_message.__init__(self, MAVLink_pass_4_message.id, MAVLink_pass_4_message.name)
                self._fieldnames = MAVLink_pass_4_message.fieldnames
                self._instance_field = MAVLink_pass_4_message.instance_field
                self._instance_offset = MAVLink_pass_4_message.instance_offset
                self.code = code
                self.val = val

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 215, struct.pack('<B4B', self.code, self.val[0], self.val[1], self.val[2], self.val[3]), force_mavlink1=force_mavlink1)

class MAVLink_pass_8_message(MAVLink_message):
        '''
        PASS 8 byte
        '''
        id = MAVLINK_MSG_ID_PASS_8
        name = 'PASS_8'
        fieldnames = ['code', 'val']
        ordered_fieldnames = ['code', 'val']
        fieldtypes = ['uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<B8B'
        native_format = bytearray('<BB', 'ascii')
        orders = [0, 1]
        lengths = [1, 8]
        array_lengths = [0, 8]
        crc_extra = 204
        unpacker = struct.Struct('<B8B')
        instance_field = None
        instance_offset = -1

        def __init__(self, code, val):
                MAVLink_message.__init__(self, MAVLink_pass_8_message.id, MAVLink_pass_8_message.name)
                self._fieldnames = MAVLink_pass_8_message.fieldnames
                self._instance_field = MAVLink_pass_8_message.instance_field
                self._instance_offset = MAVLink_pass_8_message.instance_offset
                self.code = code
                self.val = val

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 204, struct.pack('<B8B', self.code, self.val[0], self.val[1], self.val[2], self.val[3], self.val[4], self.val[5], self.val[6], self.val[7]), force_mavlink1=force_mavlink1)

class MAVLink_pass_16_message(MAVLink_message):
        '''
        PASS 16 byte
        '''
        id = MAVLINK_MSG_ID_PASS_16
        name = 'PASS_16'
        fieldnames = ['code', 'val']
        ordered_fieldnames = ['code', 'val']
        fieldtypes = ['uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<B16B'
        native_format = bytearray('<BB', 'ascii')
        orders = [0, 1]
        lengths = [1, 16]
        array_lengths = [0, 16]
        crc_extra = 249
        unpacker = struct.Struct('<B16B')
        instance_field = None
        instance_offset = -1

        def __init__(self, code, val):
                MAVLink_message.__init__(self, MAVLink_pass_16_message.id, MAVLink_pass_16_message.name)
                self._fieldnames = MAVLink_pass_16_message.fieldnames
                self._instance_field = MAVLink_pass_16_message.instance_field
                self._instance_offset = MAVLink_pass_16_message.instance_offset
                self.code = code
                self.val = val

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 249, struct.pack('<B16B', self.code, self.val[0], self.val[1], self.val[2], self.val[3], self.val[4], self.val[5], self.val[6], self.val[7], self.val[8], self.val[9], self.val[10], self.val[11], self.val[12], self.val[13], self.val[14], self.val[15]), force_mavlink1=force_mavlink1)

class MAVLink_pass_32_message(MAVLink_message):
        '''
        PASS 32 byte
        '''
        id = MAVLINK_MSG_ID_PASS_32
        name = 'PASS_32'
        fieldnames = ['code', 'val']
        ordered_fieldnames = ['code', 'val']
        fieldtypes = ['uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<B32B'
        native_format = bytearray('<BB', 'ascii')
        orders = [0, 1]
        lengths = [1, 32]
        array_lengths = [0, 32]
        crc_extra = 169
        unpacker = struct.Struct('<B32B')
        instance_field = None
        instance_offset = -1

        def __init__(self, code, val):
                MAVLink_message.__init__(self, MAVLink_pass_32_message.id, MAVLink_pass_32_message.name)
                self._fieldnames = MAVLink_pass_32_message.fieldnames
                self._instance_field = MAVLink_pass_32_message.instance_field
                self._instance_offset = MAVLink_pass_32_message.instance_offset
                self.code = code
                self.val = val

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 169, struct.pack('<B32B', self.code, self.val[0], self.val[1], self.val[2], self.val[3], self.val[4], self.val[5], self.val[6], self.val[7], self.val[8], self.val[9], self.val[10], self.val[11], self.val[12], self.val[13], self.val[14], self.val[15], self.val[16], self.val[17], self.val[18], self.val[19], self.val[20], self.val[21], self.val[22], self.val[23], self.val[24], self.val[25], self.val[26], self.val[27], self.val[28], self.val[29], self.val[30], self.val[31]), force_mavlink1=force_mavlink1)

class MAVLink_pass_64_message(MAVLink_message):
        '''
        PASS 64 byte
        '''
        id = MAVLINK_MSG_ID_PASS_64
        name = 'PASS_64'
        fieldnames = ['code', 'val']
        ordered_fieldnames = ['code', 'val']
        fieldtypes = ['uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<B64B'
        native_format = bytearray('<BB', 'ascii')
        orders = [0, 1]
        lengths = [1, 64]
        array_lengths = [0, 64]
        crc_extra = 221
        unpacker = struct.Struct('<B64B')
        instance_field = None
        instance_offset = -1

        def __init__(self, code, val):
                MAVLink_message.__init__(self, MAVLink_pass_64_message.id, MAVLink_pass_64_message.name)
                self._fieldnames = MAVLink_pass_64_message.fieldnames
                self._instance_field = MAVLink_pass_64_message.instance_field
                self._instance_offset = MAVLink_pass_64_message.instance_offset
                self.code = code
                self.val = val

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 221, struct.pack('<B64B', self.code, self.val[0], self.val[1], self.val[2], self.val[3], self.val[4], self.val[5], self.val[6], self.val[7], self.val[8], self.val[9], self.val[10], self.val[11], self.val[12], self.val[13], self.val[14], self.val[15], self.val[16], self.val[17], self.val[18], self.val[19], self.val[20], self.val[21], self.val[22], self.val[23], self.val[24], self.val[25], self.val[26], self.val[27], self.val[28], self.val[29], self.val[30], self.val[31], self.val[32], self.val[33], self.val[34], self.val[35], self.val[36], self.val[37], self.val[38], self.val[39], self.val[40], self.val[41], self.val[42], self.val[43], self.val[44], self.val[45], self.val[46], self.val[47], self.val[48], self.val[49], self.val[50], self.val[51], self.val[52], self.val[53], self.val[54], self.val[55], self.val[56], self.val[57], self.val[58], self.val[59], self.val[60], self.val[61], self.val[62], self.val[63]), force_mavlink1=force_mavlink1)

class MAVLink_pass_128_message(MAVLink_message):
        '''
        PASS 128 byte
        '''
        id = MAVLINK_MSG_ID_PASS_128
        name = 'PASS_128'
        fieldnames = ['code', 'val']
        ordered_fieldnames = ['code', 'val']
        fieldtypes = ['uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<B128B'
        native_format = bytearray('<BB', 'ascii')
        orders = [0, 1]
        lengths = [1, 128]
        array_lengths = [0, 128]
        crc_extra = 237
        unpacker = struct.Struct('<B128B')
        instance_field = None
        instance_offset = -1

        def __init__(self, code, val):
                MAVLink_message.__init__(self, MAVLink_pass_128_message.id, MAVLink_pass_128_message.name)
                self._fieldnames = MAVLink_pass_128_message.fieldnames
                self._instance_field = MAVLink_pass_128_message.instance_field
                self._instance_offset = MAVLink_pass_128_message.instance_offset
                self.code = code
                self.val = val

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 237, struct.pack('<B128B', self.code, self.val[0], self.val[1], self.val[2], self.val[3], self.val[4], self.val[5], self.val[6], self.val[7], self.val[8], self.val[9], self.val[10], self.val[11], self.val[12], self.val[13], self.val[14], self.val[15], self.val[16], self.val[17], self.val[18], self.val[19], self.val[20], self.val[21], self.val[22], self.val[23], self.val[24], self.val[25], self.val[26], self.val[27], self.val[28], self.val[29], self.val[30], self.val[31], self.val[32], self.val[33], self.val[34], self.val[35], self.val[36], self.val[37], self.val[38], self.val[39], self.val[40], self.val[41], self.val[42], self.val[43], self.val[44], self.val[45], self.val[46], self.val[47], self.val[48], self.val[49], self.val[50], self.val[51], self.val[52], self.val[53], self.val[54], self.val[55], self.val[56], self.val[57], self.val[58], self.val[59], self.val[60], self.val[61], self.val[62], self.val[63], self.val[64], self.val[65], self.val[66], self.val[67], self.val[68], self.val[69], self.val[70], self.val[71], self.val[72], self.val[73], self.val[74], self.val[75], self.val[76], self.val[77], self.val[78], self.val[79], self.val[80], self.val[81], self.val[82], self.val[83], self.val[84], self.val[85], self.val[86], self.val[87], self.val[88], self.val[89], self.val[90], self.val[91], self.val[92], self.val[93], self.val[94], self.val[95], self.val[96], self.val[97], self.val[98], self.val[99], self.val[100], self.val[101], self.val[102], self.val[103], self.val[104], self.val[105], self.val[106], self.val[107], self.val[108], self.val[109], self.val[110], self.val[111], self.val[112], self.val[113], self.val[114], self.val[115], self.val[116], self.val[117], self.val[118], self.val[119], self.val[120], self.val[121], self.val[122], self.val[123], self.val[124], self.val[125], self.val[126], self.val[127]), force_mavlink1=force_mavlink1)


mavlink_map = {
        MAVLINK_MSG_ID_MODE_RESPONSE : MAVLink_mode_response_message,
        MAVLINK_MSG_ID_BOOT_ACK : MAVLink_boot_ack_message,
        MAVLINK_MSG_ID_BOOT_COMMAND : MAVLink_boot_command_message,
        MAVLINK_MSG_ID_BOOT_OTA_READ : MAVLink_boot_ota_read_message,
        MAVLINK_MSG_ID_BOOT_OTA_WRITE : MAVLink_boot_ota_write_message,
        MAVLINK_MSG_ID_BOOT_VERSION : MAVLink_boot_version_message,
        MAVLINK_MSG_ID_BOOT_OTA_VERIFY : MAVLink_boot_ota_verify_message,
        MAVLINK_MSG_ID_SMARTSEAT_ACK : MAVLink_smartseat_ack_message,
        MAVLINK_MSG_ID_BCG_ACC : MAVLink_bcg_acc_message,
        MAVLINK_MSG_ID_BIO_STATUS : MAVLink_bio_status_message,
        MAVLINK_MSG_ID_FATIGUE : MAVLink_fatigue_message,
        MAVLINK_MSG_ID_BLE_ACK : MAVLink_ble_ack_message,
        MAVLINK_MSG_ID_BLUETOOTH_CHANGE_NAME : MAVLink_bluetooth_change_name_message,
        MAVLINK_MSG_ID_PASS_1 : MAVLink_pass_1_message,
        MAVLINK_MSG_ID_PASS_2 : MAVLink_pass_2_message,
        MAVLINK_MSG_ID_PASS_4 : MAVLink_pass_4_message,
        MAVLINK_MSG_ID_PASS_8 : MAVLink_pass_8_message,
        MAVLINK_MSG_ID_PASS_16 : MAVLink_pass_16_message,
        MAVLINK_MSG_ID_PASS_32 : MAVLink_pass_32_message,
        MAVLINK_MSG_ID_PASS_64 : MAVLink_pass_64_message,
        MAVLINK_MSG_ID_PASS_128 : MAVLink_pass_128_message,
}

class MAVError(Exception):
        '''MAVLink error class'''
        def __init__(self, msg):
            Exception.__init__(self, msg)
            self.message = msg

class MAVString(str):
        '''NUL terminated string'''
        def __init__(self, s):
                str.__init__(self)
        def __str__(self):
            i = self.find(chr(0))
            if i == -1:
                return self[:]
            return self[0:i]

class MAVLink_bad_data(MAVLink_message):
        '''
        a piece of bad data in a mavlink stream
        '''
        def __init__(self, data, reason):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_BAD_DATA, 'BAD_DATA')
                self._fieldnames = ['data', 'reason']
                self.data = data
                self.reason = reason
                self._msgbuf = data
                self._instance_field = None

        def __str__(self):
            '''Override the __str__ function from MAVLink_messages because non-printable characters are common in to be the reason for this message to exist.'''
            return '%s {%s, data:%s}' % (self._type, self.reason, [('%x' % ord(i) if isinstance(i, str) else '%x' % i) for i in self.data])

class MAVLinkSigning(object):
    '''MAVLink signing state class'''
    def __init__(self):
        self.secret_key = None
        self.timestamp = 0
        self.link_id = 0
        self.sign_outgoing = False
        self.allow_unsigned_callback = None
        self.stream_timestamps = {}
        self.sig_count = 0
        self.badsig_count = 0
        self.goodsig_count = 0
        self.unsigned_count = 0
        self.reject_count = 0

class MAVLink(object):
        '''MAVLink protocol handling class'''
        def __init__(self, file, srcSystem=0, srcComponent=0, use_native=False):
                self.seq = 0
                self.file = file
                self.srcSystem = srcSystem
                self.srcComponent = srcComponent
                self.callback = None
                self.callback_args = None
                self.callback_kwargs = None
                self.send_callback = None
                self.send_callback_args = None
                self.send_callback_kwargs = None
                self.buf = bytearray()
                self.buf_index = 0
                self.expected_length = HEADER_LEN_V1+2
                self.have_prefix_error = False
                self.robust_parsing = False
                self.protocol_marker = 254
                self.little_endian = True
                self.crc_extra = True
                self.sort_fields = True
                self.total_packets_sent = 0
                self.total_bytes_sent = 0
                self.total_packets_received = 0
                self.total_bytes_received = 0
                self.total_receive_errors = 0
                self.startup_time = time.time()
                self.signing = MAVLinkSigning()
                if native_supported and (use_native or native_testing or native_force):
                    print("NOTE: mavnative is currently beta-test code")
                    self.native = mavnative.NativeConnection(MAVLink_message, mavlink_map)
                else:
                    self.native = None
                if native_testing:
                    self.test_buf = bytearray()
                self.mav20_unpacker = struct.Struct('<cBBBBBBHB')
                self.mav10_unpacker = struct.Struct('<cBBBBB')
                self.mav20_h3_unpacker = struct.Struct('BBB')
                self.mav_csum_unpacker = struct.Struct('<H')
                self.mav_sign_unpacker = struct.Struct('<IH')

        def set_callback(self, callback, *args, **kwargs):
            self.callback = callback
            self.callback_args = args
            self.callback_kwargs = kwargs

        def set_send_callback(self, callback, *args, **kwargs):
            self.send_callback = callback
            self.send_callback_args = args
            self.send_callback_kwargs = kwargs

        def send(self, mavmsg, force_mavlink1=False):
                '''send a MAVLink message'''
                buf = mavmsg.pack(self, force_mavlink1=force_mavlink1)
                self.file.write(buf)
                self.seq = (self.seq + 1) % 256
                self.total_packets_sent += 1
                self.total_bytes_sent += len(buf)
                if self.send_callback:
                    self.send_callback(mavmsg, *self.send_callback_args, **self.send_callback_kwargs)

        def buf_len(self):
            return len(self.buf) - self.buf_index

        def bytes_needed(self):
            '''return number of bytes needed for next parsing stage'''
            if self.native:
                ret = self.native.expected_length - self.buf_len()
            else:
                ret = self.expected_length - self.buf_len()

            if ret <= 0:
                return 1
            return ret

        def __parse_char_native(self, c):
            '''this method exists only to see in profiling results'''
            m = self.native.parse_chars(c)
            return m

        def __callbacks(self, msg):
            '''this method exists only to make profiling results easier to read'''
            if self.callback:
                self.callback(msg, *self.callback_args, **self.callback_kwargs)

        def parse_char(self, c):
            '''input some data bytes, possibly returning a new message'''
            self.buf.extend(c)

            self.total_bytes_received += len(c)

            if self.native:
                if native_testing:
                    self.test_buf.extend(c)
                    m = self.__parse_char_native(self.test_buf)
                    m2 = self.__parse_char_legacy()
                    if m2 != m:
                        print("Native: %s\nLegacy: %s\n" % (m, m2))
                        raise Exception('Native vs. Legacy mismatch')
                else:
                    m = self.__parse_char_native(self.buf)
            else:
                m = self.__parse_char_legacy()

            if m is not None:
                self.total_packets_received += 1
                self.__callbacks(m)
            else:
                # XXX The idea here is if we've read something and there's nothing left in
                # the buffer, reset it to 0 which frees the memory
                if self.buf_len() == 0 and self.buf_index != 0:
                    self.buf = bytearray()
                    self.buf_index = 0

            return m

        def __parse_char_legacy(self):
            '''input some data bytes, possibly returning a new message (uses no native code)'''
            header_len = HEADER_LEN_V1
            if self.buf_len() >= 1 and self.buf[self.buf_index] == PROTOCOL_MARKER_V2:
                header_len = HEADER_LEN_V2

            if self.buf_len() >= 1 and self.buf[self.buf_index] != PROTOCOL_MARKER_V1 and self.buf[self.buf_index] != PROTOCOL_MARKER_V2:
                magic = self.buf[self.buf_index]
                self.buf_index += 1
                if self.robust_parsing:
                    m = MAVLink_bad_data(bytearray([magic]), 'Bad prefix')
                    self.expected_length = header_len+2
                    self.total_receive_errors += 1
                    return m
                if self.have_prefix_error:
                    return None
                self.have_prefix_error = True
                self.total_receive_errors += 1
                raise MAVError("invalid MAVLink prefix '%s'" % magic)
            self.have_prefix_error = False
            if self.buf_len() >= 3:
                sbuf = self.buf[self.buf_index:3+self.buf_index]
                if sys.version_info.major < 3:
                    sbuf = str(sbuf)
                (magic, self.expected_length, incompat_flags) = self.mav20_h3_unpacker.unpack(sbuf)
                if magic == PROTOCOL_MARKER_V2 and (incompat_flags & MAVLINK_IFLAG_SIGNED):
                        self.expected_length += MAVLINK_SIGNATURE_BLOCK_LEN
                self.expected_length += header_len + 2
            if self.expected_length >= (header_len+2) and self.buf_len() >= self.expected_length:
                mbuf = array.array('B', self.buf[self.buf_index:self.buf_index+self.expected_length])
                self.buf_index += self.expected_length
                self.expected_length = header_len+2
                if self.robust_parsing:
                    try:
                        if magic == PROTOCOL_MARKER_V2 and (incompat_flags & ~MAVLINK_IFLAG_SIGNED) != 0:
                            raise MAVError('invalid incompat_flags 0x%x 0x%x %u' % (incompat_flags, magic, self.expected_length))
                        m = self.decode(mbuf)
                    except MAVError as reason:
                        m = MAVLink_bad_data(mbuf, reason.message)
                        self.total_receive_errors += 1
                else:
                    if magic == PROTOCOL_MARKER_V2 and (incompat_flags & ~MAVLINK_IFLAG_SIGNED) != 0:
                        raise MAVError('invalid incompat_flags 0x%x 0x%x %u' % (incompat_flags, magic, self.expected_length))
                    m = self.decode(mbuf)
                return m
            return None

        def parse_buffer(self, s):
            '''input some data bytes, possibly returning a list of new messages'''
            m = self.parse_char(s)
            if m is None:
                return None
            ret = [m]
            while True:
                m = self.parse_char("")
                if m is None:
                    return ret
                ret.append(m)
            return ret

        def check_signature(self, msgbuf, srcSystem, srcComponent):
            '''check signature on incoming message'''
            if isinstance(msgbuf, array.array):
                try:
                    msgbuf = msgbuf.tostring()
                except:
                    msgbuf = msgbuf.tobytes()
            timestamp_buf = msgbuf[-12:-6]
            link_id = msgbuf[-13]
            (tlow, thigh) = self.mav_sign_unpacker.unpack(timestamp_buf)
            timestamp = tlow + (thigh<<32)

            # see if the timestamp is acceptable
            stream_key = (link_id,srcSystem,srcComponent)
            if stream_key in self.signing.stream_timestamps:
                if timestamp <= self.signing.stream_timestamps[stream_key]:
                    # reject old timestamp
                    # print('old timestamp')
                    return False
            else:
                # a new stream has appeared. Accept the timestamp if it is at most
                # one minute behind our current timestamp
                if timestamp + 6000*1000 < self.signing.timestamp:
                    # print('bad new stream ', timestamp/(100.0*1000*60*60*24*365), self.signing.timestamp/(100.0*1000*60*60*24*365))
                    return False
                self.signing.stream_timestamps[stream_key] = timestamp
                # print('new stream')

            h = hashlib.new('sha256')
            h.update(self.signing.secret_key)
            h.update(msgbuf[:-6])
            if str(type(msgbuf)) == "<class 'bytes'>" or str(type(msgbuf)) == "<class 'bytearray'>":
                # Python 3
                sig1 = h.digest()[:6]
                sig2 = msgbuf[-6:]
            else:
                sig1 = str(h.digest())[:6]
                sig2 = str(msgbuf)[-6:]
            if sig1 != sig2:
                # print('sig mismatch')
                return False

            # the timestamp we next send with is the max of the received timestamp and
            # our current timestamp
            self.signing.timestamp = max(self.signing.timestamp, timestamp)
            return True

        def decode(self, msgbuf):
                '''decode a buffer as a MAVLink message'''
                # decode the header
                if msgbuf[0] != PROTOCOL_MARKER_V1:
                    headerlen = 10
                    try:
                        magic, mlen, incompat_flags, compat_flags, seq, srcSystem, srcComponent, msgIdlow, msgIdhigh = self.mav20_unpacker.unpack(msgbuf[:headerlen])
                    except struct.error as emsg:
                        raise MAVError('Unable to unpack MAVLink header: %s' % emsg)
                    msgId = msgIdlow | (msgIdhigh<<16)
                    mapkey = msgId
                else:
                    headerlen = 6
                    try:
                        magic, mlen, seq, srcSystem, srcComponent, msgId = self.mav10_unpacker.unpack(msgbuf[:headerlen])
                        incompat_flags = 0
                        compat_flags = 0
                    except struct.error as emsg:
                        raise MAVError('Unable to unpack MAVLink header: %s' % emsg)
                    mapkey = msgId
                if (incompat_flags & MAVLINK_IFLAG_SIGNED) != 0:
                    signature_len = MAVLINK_SIGNATURE_BLOCK_LEN
                else:
                    signature_len = 0

                if ord(magic) != PROTOCOL_MARKER_V1 and ord(magic) != PROTOCOL_MARKER_V2:
                    raise MAVError("invalid MAVLink prefix '%s'" % magic)
                if mlen != len(msgbuf)-(headerlen+2+signature_len):
                    raise MAVError('invalid MAVLink message length. Got %u expected %u, msgId=%u headerlen=%u' % (len(msgbuf)-(headerlen+2+signature_len), mlen, msgId, headerlen))

                if not mapkey in mavlink_map:
                    raise MAVError('unknown MAVLink message ID %s' % str(mapkey))

                # decode the payload
                type = mavlink_map[mapkey]
                fmt = type.format
                order_map = type.orders
                len_map = type.lengths
                crc_extra = type.crc_extra

                # decode the checksum
                try:
                    crc, = self.mav_csum_unpacker.unpack(msgbuf[-(2+signature_len):][:2])
                except struct.error as emsg:
                    raise MAVError('Unable to unpack MAVLink CRC: %s' % emsg)
                crcbuf = msgbuf[1:-(2+signature_len)]
                if True: # using CRC extra
                    crcbuf.append(crc_extra)
                crc2 = x25crc(crcbuf)
                if crc != crc2.crc and not MAVLINK_IGNORE_CRC:
                    raise MAVError('invalid MAVLink CRC in msgID %u 0x%04x should be 0x%04x' % (msgId, crc, crc2.crc))

                sig_ok = False
                if signature_len == MAVLINK_SIGNATURE_BLOCK_LEN:
                    self.signing.sig_count += 1
                if self.signing.secret_key is not None:
                    accept_signature = False
                    if signature_len == MAVLINK_SIGNATURE_BLOCK_LEN:
                        sig_ok = self.check_signature(msgbuf, srcSystem, srcComponent)
                        accept_signature = sig_ok
                        if sig_ok:
                            self.signing.goodsig_count += 1
                        else:
                            self.signing.badsig_count += 1
                        if not accept_signature and self.signing.allow_unsigned_callback is not None:
                            accept_signature = self.signing.allow_unsigned_callback(self, msgId)
                            if accept_signature:
                                self.signing.unsigned_count += 1
                            else:
                                self.signing.reject_count += 1
                    elif self.signing.allow_unsigned_callback is not None:
                        accept_signature = self.signing.allow_unsigned_callback(self, msgId)
                        if accept_signature:
                            self.signing.unsigned_count += 1
                        else:
                            self.signing.reject_count += 1
                    if not accept_signature:
                        raise MAVError('Invalid signature')

                csize = type.unpacker.size
                mbuf = msgbuf[headerlen:-(2+signature_len)]
                if len(mbuf) < csize:
                    # zero pad to give right size
                    mbuf.extend([0]*(csize - len(mbuf)))
                if len(mbuf) < csize:
                    raise MAVError('Bad message of type %s length %u needs %s' % (
                        type, len(mbuf), csize))
                mbuf = mbuf[:csize]
                try:
                    t = type.unpacker.unpack(mbuf)
                except struct.error as emsg:
                    raise MAVError('Unable to unpack MAVLink payload type=%s fmt=%s payloadLength=%u: %s' % (
                        type, fmt, len(mbuf), emsg))

                tlist = list(t)
                # handle sorted fields
                if True:
                    t = tlist[:]
                    if sum(len_map) == len(len_map):
                        # message has no arrays in it
                        for i in range(0, len(tlist)):
                            tlist[i] = t[order_map[i]]
                    else:
                        # message has some arrays
                        tlist = []
                        for i in range(0, len(order_map)):
                            order = order_map[i]
                            L = len_map[order]
                            tip = sum(len_map[:order])
                            field = t[tip]
                            if L == 1 or isinstance(field, str):
                                tlist.append(field)
                            else:
                                tlist.append(t[tip:(tip + L)])

                # terminate any strings
                for i in range(0, len(tlist)):
                    if type.fieldtypes[i] == 'char':
                        if sys.version_info.major >= 3:
                            tlist[i] = to_string(tlist[i])
                        tlist[i] = str(MAVString(tlist[i]))
                t = tuple(tlist)
                # construct the message object
                try:
                    m = type(*t)
                except Exception as emsg:
                    raise MAVError('Unable to instantiate MAVLink message of type %s : %s' % (type, emsg))
                m._signed = sig_ok
                if m._signed:
                    m._link_id = msgbuf[-13]
                m._msgbuf = msgbuf
                m._payload = msgbuf[6:-(2+signature_len)]
                m._crc = crc
                m._header = MAVLink_header(msgId, incompat_flags, compat_flags, mlen, seq, srcSystem, srcComponent)
                return m
        def mode_response_encode(self, mode):
                '''
                send packet and response the mode

                mode                      : mode (type:uint8_t)

                '''
                return MAVLink_mode_response_message(mode)

        def mode_response_send(self, mode, force_mavlink1=False):
                '''
                send packet and response the mode

                mode                      : mode (type:uint8_t)

                '''
                return self.send(self.mode_response_encode(mode), force_mavlink1=force_mavlink1)

        def boot_ack_encode(self, ack_code, value):
                '''
                command and ack back

                ack_code                  : acknowledge or not (type:uint8_t)
                value                     : counts (type:uint32_t)

                '''
                return MAVLink_boot_ack_message(ack_code, value)

        def boot_ack_send(self, ack_code, value, force_mavlink1=False):
                '''
                command and ack back

                ack_code                  : acknowledge or not (type:uint8_t)
                value                     : counts (type:uint32_t)

                '''
                return self.send(self.boot_ack_encode(ack_code, value), force_mavlink1=force_mavlink1)

        def boot_command_encode(self, command, value):
                '''
                Bootloader command

                command                   : command (type:uint8_t)
                value                     : value (type:uint32_t)

                '''
                return MAVLink_boot_command_message(command, value)

        def boot_command_send(self, command, value, force_mavlink1=False):
                '''
                Bootloader command

                command                   : command (type:uint8_t)
                value                     : value (type:uint32_t)

                '''
                return self.send(self.boot_command_encode(command, value), force_mavlink1=force_mavlink1)

        def boot_ota_read_encode(self, addr, counts, value, checksum):
                '''
                Bootloader ota data read

                addr                      : write address (type:uint32_t)
                counts                    : counts pages (type:uint16_t)
                value                     : ota (type:uint8_t)
                checksum                  : checksum (type:uint32_t)

                '''
                return MAVLink_boot_ota_read_message(addr, counts, value, checksum)

        def boot_ota_read_send(self, addr, counts, value, checksum, force_mavlink1=False):
                '''
                Bootloader ota data read

                addr                      : write address (type:uint32_t)
                counts                    : counts pages (type:uint16_t)
                value                     : ota (type:uint8_t)
                checksum                  : checksum (type:uint32_t)

                '''
                return self.send(self.boot_ota_read_encode(addr, counts, value, checksum), force_mavlink1=force_mavlink1)

        def boot_ota_write_encode(self, addr, counts, value, checksum):
                '''
                Bootloader ota data write

                addr                      : write address (type:uint32_t)
                counts                    : counts pages (type:uint16_t)
                value                     : ota (type:uint8_t)
                checksum                  : checksum (type:uint32_t)

                '''
                return MAVLink_boot_ota_write_message(addr, counts, value, checksum)

        def boot_ota_write_send(self, addr, counts, value, checksum, force_mavlink1=False):
                '''
                Bootloader ota data write

                addr                      : write address (type:uint32_t)
                counts                    : counts pages (type:uint16_t)
                value                     : ota (type:uint8_t)
                checksum                  : checksum (type:uint32_t)

                '''
                return self.send(self.boot_ota_write_encode(addr, counts, value, checksum), force_mavlink1=force_mavlink1)

        def boot_version_encode(self, request_code, version):
                '''
                Bootloader or app version

                request_code              : request code (BOOT_COMMAND) (type:uint8_t)
                version                   : major, patch, minor, reserve (type:uint8_t)

                '''
                return MAVLink_boot_version_message(request_code, version)

        def boot_version_send(self, request_code, version, force_mavlink1=False):
                '''
                Bootloader or app version

                request_code              : request code (BOOT_COMMAND) (type:uint8_t)
                version                   : major, patch, minor, reserve (type:uint8_t)

                '''
                return self.send(self.boot_version_encode(request_code, version), force_mavlink1=force_mavlink1)

        def boot_ota_verify_encode(self, start_addr, length, checksum):
                '''
                Verify ota flash

                start_addr                : start address (type:uint32_t)
                length                    : verify flash length (type:uint32_t)
                checksum                  : checksum, should match MCU calculated checksum (type:uint32_t)

                '''
                return MAVLink_boot_ota_verify_message(start_addr, length, checksum)

        def boot_ota_verify_send(self, start_addr, length, checksum, force_mavlink1=False):
                '''
                Verify ota flash

                start_addr                : start address (type:uint32_t)
                length                    : verify flash length (type:uint32_t)
                checksum                  : checksum, should match MCU calculated checksum (type:uint32_t)

                '''
                return self.send(self.boot_ota_verify_encode(start_addr, length, checksum), force_mavlink1=force_mavlink1)

        def smartseat_ack_encode(self, ack_code):
                '''
                command and ack back

                ack_code                  : acknowledge or not (type:uint8_t)

                '''
                return MAVLink_smartseat_ack_message(ack_code)

        def smartseat_ack_send(self, ack_code, force_mavlink1=False):
                '''
                command and ack back

                ack_code                  : acknowledge or not (type:uint8_t)

                '''
                return self.send(self.smartseat_ack_encode(ack_code), force_mavlink1=force_mavlink1)

        def bcg_acc_encode(self, timestamp, pressure, accx, accy, accz):
                '''
                Pressure raw data

                timestamp                 : timestamp (type:uint32_t)
                pressure                  : BCG raw data, sampling rate (64) (type:int32_t)
                accx                      : G sensor data X, sampling rate (64) (type:int32_t)
                accy                      : G sensor data Y, sampling rate (64) (type:int32_t)
                accz                      : G sensor data Z, sampling rate (64) (type:int32_t)

                '''
                return MAVLink_bcg_acc_message(timestamp, pressure, accx, accy, accz)

        def bcg_acc_send(self, timestamp, pressure, accx, accy, accz, force_mavlink1=False):
                '''
                Pressure raw data

                timestamp                 : timestamp (type:uint32_t)
                pressure                  : BCG raw data, sampling rate (64) (type:int32_t)
                accx                      : G sensor data X, sampling rate (64) (type:int32_t)
                accy                      : G sensor data Y, sampling rate (64) (type:int32_t)
                accz                      : G sensor data Z, sampling rate (64) (type:int32_t)

                '''
                return self.send(self.bcg_acc_encode(timestamp, pressure, accx, accy, accz), force_mavlink1=force_mavlink1)

        def bio_status_encode(self, timestamp, hr, resp, status):
                '''
                Fatigue data

                timestamp                 : timestamp (type:uint32_t)
                hr                        : heart rate (type:uint8_t)
                resp                      : respiratory (type:uint8_t)
                status                    : status (type:uint8_t)

                '''
                return MAVLink_bio_status_message(timestamp, hr, resp, status)

        def bio_status_send(self, timestamp, hr, resp, status, force_mavlink1=False):
                '''
                Fatigue data

                timestamp                 : timestamp (type:uint32_t)
                hr                        : heart rate (type:uint8_t)
                resp                      : respiratory (type:uint8_t)
                status                    : status (type:uint8_t)

                '''
                return self.send(self.bio_status_encode(timestamp, hr, resp, status), force_mavlink1=force_mavlink1)

        def fatigue_encode(self, timestamp, fatigue, alarm):
                '''
                Fatigue data

                timestamp                 : timestamp (type:uint32_t)
                fatigue                   : fatigue data (type:uint8_t)
                alarm                     : alarm data (type:uint8_t)

                '''
                return MAVLink_fatigue_message(timestamp, fatigue, alarm)

        def fatigue_send(self, timestamp, fatigue, alarm, force_mavlink1=False):
                '''
                Fatigue data

                timestamp                 : timestamp (type:uint32_t)
                fatigue                   : fatigue data (type:uint8_t)
                alarm                     : alarm data (type:uint8_t)

                '''
                return self.send(self.fatigue_encode(timestamp, fatigue, alarm), force_mavlink1=force_mavlink1)

        def ble_ack_encode(self, ack_code):
                '''
                wifi connect

                ack_code                  : acknowledge or not (type:uint8_t)

                '''
                return MAVLink_ble_ack_message(ack_code)

        def ble_ack_send(self, ack_code, force_mavlink1=False):
                '''
                wifi connect

                ack_code                  : acknowledge or not (type:uint8_t)

                '''
                return self.send(self.ble_ack_encode(ack_code), force_mavlink1=force_mavlink1)

        def bluetooth_change_name_encode(self, name):
                '''
                BMWSeat control

                name                      : change bluetooth device name (type:uint8_t)

                '''
                return MAVLink_bluetooth_change_name_message(name)

        def bluetooth_change_name_send(self, name, force_mavlink1=False):
                '''
                BMWSeat control

                name                      : change bluetooth device name (type:uint8_t)

                '''
                return self.send(self.bluetooth_change_name_encode(name), force_mavlink1=force_mavlink1)

        def pass_1_encode(self, code, val):
                '''
                PASS 1 byte

                code                      : code (type:uint8_t)
                val                       : value (type:uint8_t)

                '''
                return MAVLink_pass_1_message(code, val)

        def pass_1_send(self, code, val, force_mavlink1=False):
                '''
                PASS 1 byte

                code                      : code (type:uint8_t)
                val                       : value (type:uint8_t)

                '''
                return self.send(self.pass_1_encode(code, val), force_mavlink1=force_mavlink1)

        def pass_2_encode(self, code, val):
                '''
                PASS 2 byte

                code                      : code (type:uint8_t)
                val                       : value (type:uint8_t)

                '''
                return MAVLink_pass_2_message(code, val)

        def pass_2_send(self, code, val, force_mavlink1=False):
                '''
                PASS 2 byte

                code                      : code (type:uint8_t)
                val                       : value (type:uint8_t)

                '''
                return self.send(self.pass_2_encode(code, val), force_mavlink1=force_mavlink1)

        def pass_4_encode(self, code, val):
                '''
                PASS 4 byte

                code                      : code (type:uint8_t)
                val                       : value (type:uint8_t)

                '''
                return MAVLink_pass_4_message(code, val)

        def pass_4_send(self, code, val, force_mavlink1=False):
                '''
                PASS 4 byte

                code                      : code (type:uint8_t)
                val                       : value (type:uint8_t)

                '''
                return self.send(self.pass_4_encode(code, val), force_mavlink1=force_mavlink1)

        def pass_8_encode(self, code, val):
                '''
                PASS 8 byte

                code                      : code (type:uint8_t)
                val                       : value (type:uint8_t)

                '''
                return MAVLink_pass_8_message(code, val)

        def pass_8_send(self, code, val, force_mavlink1=False):
                '''
                PASS 8 byte

                code                      : code (type:uint8_t)
                val                       : value (type:uint8_t)

                '''
                return self.send(self.pass_8_encode(code, val), force_mavlink1=force_mavlink1)

        def pass_16_encode(self, code, val):
                '''
                PASS 16 byte

                code                      : code (type:uint8_t)
                val                       : value (type:uint8_t)

                '''
                return MAVLink_pass_16_message(code, val)

        def pass_16_send(self, code, val, force_mavlink1=False):
                '''
                PASS 16 byte

                code                      : code (type:uint8_t)
                val                       : value (type:uint8_t)

                '''
                return self.send(self.pass_16_encode(code, val), force_mavlink1=force_mavlink1)

        def pass_32_encode(self, code, val):
                '''
                PASS 32 byte

                code                      : code (type:uint8_t)
                val                       : value (type:uint8_t)

                '''
                return MAVLink_pass_32_message(code, val)

        def pass_32_send(self, code, val, force_mavlink1=False):
                '''
                PASS 32 byte

                code                      : code (type:uint8_t)
                val                       : value (type:uint8_t)

                '''
                return self.send(self.pass_32_encode(code, val), force_mavlink1=force_mavlink1)

        def pass_64_encode(self, code, val):
                '''
                PASS 64 byte

                code                      : code (type:uint8_t)
                val                       : value (type:uint8_t)

                '''
                return MAVLink_pass_64_message(code, val)

        def pass_64_send(self, code, val, force_mavlink1=False):
                '''
                PASS 64 byte

                code                      : code (type:uint8_t)
                val                       : value (type:uint8_t)

                '''
                return self.send(self.pass_64_encode(code, val), force_mavlink1=force_mavlink1)

        def pass_128_encode(self, code, val):
                '''
                PASS 128 byte

                code                      : code (type:uint8_t)
                val                       : value (type:uint8_t)

                '''
                return MAVLink_pass_128_message(code, val)

        def pass_128_send(self, code, val, force_mavlink1=False):
                '''
                PASS 128 byte

                code                      : code (type:uint8_t)
                val                       : value (type:uint8_t)

                '''
                return self.send(self.pass_128_encode(code, val), force_mavlink1=force_mavlink1)

